/**\n * Events - ëžœë¤ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ\n * ëŸ°ë‹¹ 2~4íšŒ ë°œìƒ, ê¸´ìž¥ê° + ë³€ì£¼ ì œê³µ\n */\n\nimport { MSG } from './messages.js';\n\nexport class Events {\n  constructor(game) {\n    this.game = game;\n\n    this.eventTypes = {\n      blackout: {\n        id: 'blackout',\n        name: 'ì •ì „',\n        message: 'âš¡ [ê²½ê³ ] ì •ì „ ë°œìƒ! ì „ë ¥ì´ ê¸‰ê°í•©ë‹ˆë‹¤.',\n        effect: (g) => {\n          g.state.resources.power = Math.max(0, g.state.resources.power - 20);\n          this.disableScanFor(3);\n        },\n        duration: 3,\n        positive: false,\n      },\n      o2leak: {\n        id: 'o2leak',\n        name: 'ì‚°ì†Œ ëˆ„ì¶œ',\n        message: 'ðŸ’¨ [ê²½ê³ ] ì‚°ì†Œ ëˆ„ì¶œ ê°ì§€! ì´ êµ¬ì—­ì˜ ì‚°ì†Œê°€ ë¹ ë¥´ê²Œ ê°ì†Œí•©ë‹ˆë‹¤.',\n        effect: (g) => {\n          this.activeO2Leak = true;\n          this.o2LeakRoom = g.state.location;\n        },\n        duration: 10,\n        positive: false,\n      },\n      noisespike: {\n        id: 'noisespike',\n        name: 'ì†ŒìŒ ê°ì§€',\n        message: 'ðŸ“¡ [ê²½ê³ ] ì†ŒìŒ ìŠ¤íŒŒì´í¬! ì ì´ ë¹ ë¥´ê²Œ ì ‘ê·¼í•©ë‹ˆë‹¤.',\n        effect: (g) => {\n          g.state.enemy.distance = Math.max(0, g.state.enemy.distance - 1);\n          g.state.resources.noise = Math.min(100, g.state.resources.noise + 20);\n        },\n        duration: 0,\n        positive: false,\n      },\n      glitch: {\n        id: 'glitch',\n        name: 'ì‹œìŠ¤í…œ ì˜¤ë¥˜',\n        message: 'ðŸ”§ [ê²½ê³ ] ì‹œìŠ¤í…œ ê¸€ë¦¬ì¹˜! ë‹¤ìŒ ëª…ë ¹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤.',\n        effect: () => {\n          this.nextCommandMayFail = true;\n        },\n        duration: 0,\n        positive: false,\n      },\n      powersurge: {\n        id: 'powersurge',\n        name: 'ì „ë ¥ ì„œì§€',\n        message: 'âš¡ [ì•Œë¦¼] ì˜ˆë¹„ ì „ë ¥ ê³µê¸‰! ì „ë ¥ì´ íšŒë³µë©ë‹ˆë‹¤.',\n        effect: (g) => {\n          g.state.resources.power = Math.min(100, g.state.resources.power + 15);\n        },\n        duration: 0,\n        positive: true,\n      },\n    };\n\n    this.eventCount = 0;\n    this.maxEvents = 4;\n    this.minTicksBetweenEvents = 15;\n    this.lastEventTick = 0;\n\n    this.scanDisabledUntil = 0;\n    this.activeO2Leak = false;\n    this.o2LeakRoom = null;\n    this.o2LeakEndTick = 0;\n    this.nextCommandMayFail = false;\n  }\n\n  isTutorialRun() {\n    // íŠœí† ë¦¬ì–¼ì´ ì™„ë£Œë˜ì§€ ì•Šì•˜ìœ¼ë©´ íŠœí† ë¦¬ì–¼ ëŸ°\n    return this.game?.tutorial && !this.game.tutorial.isCompleted();\n  }\n\n  tick() {\n    const { time } = this.game.state;\n\n    // O2 ëˆ„ì¶œ íš¨ê³¼\n    if (this.activeO2Leak) {\n      if (time >= this.o2LeakEndTick) {\n        this.activeO2Leak = false;\n        this.game.leftPanel?.logEvent('ðŸ’¨ ì‚°ì†Œ ëˆ„ì¶œì´ ë©ˆì·„ìŠµë‹ˆë‹¤.', 'success');\n      } else if (this.game.state.location === this.o2LeakRoom) {\n        this.game.state.resources.o2 = Math.max(0, this.game.state.resources.o2 - 1);\n      }\n    }\n\n    // íŠœí† ë¦¬ì–¼ ëŸ°ì—ëŠ” ëžœë¤ ì´ë²¤íŠ¸ ë°œìƒ ê¸ˆì§€\n    if (!this.isTutorialRun()) {\n      this.checkRandomEvent();\n    }\n\n    // í™œì„± íš¨ê³¼ ì—…ë°ì´íŠ¸\n    this.game.leftPanel?.updateEffects(this.getActiveEffects());\n  }\n\n  checkRandomEvent() {\n    const { time, resources, enemy } = this.game.state;\n\n    if (this.eventCount >= this.maxEvents) return;\n    if (time - this.lastEventTick < this.minTicksBetweenEvents) return;\n    if (time < 30) return;\n\n    let chance = 0.03;\n    if (resources.noise > 50) chance += 0.02;\n    if (resources.noise > 80) chance += 0.03;\n    if (enemy.distance <= 2) chance += 0.02;\n\n    if (Math.random() < chance) {\n      this.triggerRandomEvent();\n    }\n  }\n\n  triggerRandomEvent() {\n    const weights = {\n      blackout: 25,\n      o2leak: 20,\n      noisespike: 25,\n      glitch: 20,\n      powersurge: 10,\n    };\n\n    const eventId = this.weightedRandom(weights);\n    const event = this.eventTypes[eventId];\n    if (!event) return;\n\n    this.eventCount++;\n    this.lastEventTick = this.game.state.time;\n\n    // ì¢Œì¸¡ íŒ¨ë„ì— ê¸°ë¡\n    this.game.leftPanel?.logEvent(event.message, event.positive ? 'success' : 'warning');\n\n    // ì—…ì  í”Œëž˜ê·¸\n    this.game.achievements?.check('event', { type: event.id });\n\n    // íš¨ê³¼ ì ìš©\n    event.effect(this.game);\n\n    if (event.id === 'o2leak') {\n      this.o2LeakEndTick = this.game.state.time + event.duration;\n    }\n\n    if (!event.positive) {\n      this.game.crt.glitch(400);\n      this.game.terminalEl.classList.add('error-flash');\n      setTimeout(() => this.game.terminalEl.classList.remove('error-flash'), 200);\n    }\n  }\n\n  weightedRandom(weights) {\n    const total = Object.values(weights).reduce((a, b) => a + b, 0);\n    let rand = Math.random() * total;\n\n    for (const [key, weight] of Object.entries(weights)) {\n      rand -= weight;\n      if (rand <= 0) return key;\n    }\n\n    return Object.keys(weights)[0];\n  }\n\n  disableScanFor(seconds) {\n    this.scanDisabledUntil = this.game.state.time + seconds;\n  }\n\n  isBlackout() {\n    return this.game.state.time < this.scanDisabledUntil;\n  }\n\n  getLeakRoom() {\n    return this.activeO2Leak ? this.o2LeakRoom : null;\n  }\n\n  checkGlitchFail() {\n    if (this.nextCommandMayFail) {\n      this.nextCommandMayFail = false;\n      if (Math.random() < 0.3) {\n        this.game.leftPanel?.logEvent('ðŸ”§ ì‹œìŠ¤í…œ ì˜¤ë¥˜ë¡œ ëª…ë ¹ ì‹¤í–‰ ì‹¤íŒ¨!', 'error');\n        this.game.triggerError();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  getActiveEffects() {\n    const effects = [];\n\n    if (this.isBlackout()) {\n      effects.push('ìŠ¤ìº” ë¶ˆê°€ (ì •ì „)');\n    }\n\n    if (this.activeO2Leak) {\n      effects.push(`ì‚°ì†Œ ëˆ„ì¶œ (${MSG.ROOMS[this.o2LeakRoom]})`);\n    }\n\n    if (this.nextCommandMayFail) {\n      effects.push('ì‹œìŠ¤í…œ ë¶ˆì•ˆì •');\n    }\n\n    return effects;\n  }\n\n  // êµ¬ë²„ì „ í˜¸í™˜\n  showStatus() {}\n}\n